# Casbin Access Control Model
# Defines the grammar for our authorization policies.

[request_definition]
# The inputs for an authorization check, provided by our middleware.
# sub: The subject (user's roles, as a JSON string).
# obj: The object/resource being accessed (the URL path).
# act: The action being performed (e.g., "create:project").
r = sub, obj, act

[policy_definition]
# The structure of a single rule in our policy.csv file.
# sub: The role the policy applies to (e.g., "role_president").
p = sub, obj, act, eft

[policy_effect]
# Defines how decisions are made if multiple rules match.
# "some(where (p.eft == allow))" means: if any single matching rule is "allow",
# then the final result is "allow". This is perfect for handling multiple roles.
e = some(where (p.eft == allow))

[matchers]
# The core logic that connects a request to the policy.
# 1. hasRole(r.sub, p.sub): Our custom function checks if the user's role list (r.sub) contains the policy's role (p.sub).
# 2. keyMatch2(r.obj, p.obj): A built-in function that matches URL paths with wildcards (*) and parameters (:id).
# 3. keyMatch(r.act, p.act): A built-in function that matches actions with wildcards (*).
m = hasRole(r.sub, p.sub) && keyMatch2(r.obj, p.obj) && keyMatch(r.act, p.act)